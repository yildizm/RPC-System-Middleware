#!/usr/bin/env pyth
# -*- coding: utf-8 -*-

from __future__ import division
from string import Template
import numbers, json, jsonpickle, Pyro4, socket, select, exceptions, inspect, sys
try:
	import cPickle as cPickle
except:
	import pickle


'''This is the code template for client stubs. It includes code segments that are common for any stub
These code blocks are merged with service/function dependent segments of each stub using python
string Templates different sorts'''

STUB_CODE_BLOCKS = {\
'file_init' : """#!/usr/bin/env pyth
# -*- coding: utf-8 -*-

from __future__ import division
import numbers, json, jsonpickle, Pyro4, socket, select, exceptions, inspect, sys

'''Automatically generated client stub script.
Please do not edit this file by any means'''

MSGLEN = 4096
SERVERNAME = """,\
'class_init' : """
	def __init__(self, timeout=10000, retry_count=5):
		self.server = SERVERNAME
		self.timeout = timeout
		self.retry_count = retry_count
""", \
'send_request' : """	def send_request(self, func_name, serialized_data, soc):
		param_length = len(serialized_data)
		data = json.dumps({"size" : param_length, "func" : func_name, "param" : serialized_data})
		msg_len = len(data)
		sent_amount = 0
		while sent_amount < msg_len:
			temp = soc.send(data[sent_amount:])
			if temp == 0:
				raise IOError(0, 'Remote server socket disconnected')
			sent_amount += temp

		return 1
""", \
'receive_response' : """	def receive_response(self, soc, timeout):
		data = ''
		try:
			check = select.select([soc], [], [], timeout)
			if check[0]:
				data = soc.recv(MSGLEN)
				if data == '':
					raise IOError(0, 'Remote server socket disconnected')
			else:
				raise IOError(1, 'Error while waiting response from remote server')
		except select.error as err:
			raise err

		return data
""", \
'remote_function_type_check' : """		# apply necessary type checkings
		if""",\
'remote_function_nameserver' : """		# locate the server and retrieve connection information
		# Pyro is used only for getting remote server ip and port, from a dummy proxy object
		Pyro4.config.REQUIRE_EXPOSE = False
		try:
			name_server = Pyro4.locateNS()
		except NamingError:
			print 'Client Name Server Error:'
			print ''.join(Pyro4.util.getPyroTraceback())
			return None, 'Failed to locate name server'

		# locate the server and retrieve its address
		uri = name_server.lookup(self.server)
		remote_server = Pyro4.Proxy(uri)
		server_ip = remote_server.get_host()
		server_port = remote_server.get_port()
		print 'Located remote server at ' + server_ip + ':' + str(server_port)
""", \
'remote_function_marshalling_begin' : """		param_list = """, \
'remote_function_marshalling_end' : """		marshalled_param = jsonpickle.encode(param_list)
		func_name = inspect.stack()[0][3]
""", \
'remote_function_connection' : """		# try to initiate a conection witht the server
		soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		try:
			soc.connect((server_ip, int(server_port)))
		except socket.error as err:
			print 'Client Socket Connection Error:\\n {0}: {1}'.format(err.no, err.strerror)
			soc.shutdown()
			soc.close()
			return None, 'Failed to connect to the remote server'
""", \
'remote_function_send_request' : """		count = -1
		status = 0
		while count < self.retry_count and status == 0:
			count += 1
			# send the function name and its parameters to remote server
			try:
				status = self.send_request(func_name, marshalled_param, soc)
			except IOError as err:
				print 'Client Remote Server Connection Error\\n: {0}: {1}'.format(err[0], err[1])
				soc.shutdown(1)
				soc.close()
				#return None, 'Problem while communicating with the remote server'

		if count == self.retry_count:
			return None, 'Client retry count reached'
""", \
'remote_function_receive_response' : """		# wait for a response from the server in a proper json format
		count -= 1
		response = ''
		while count < self.retry_count and response == '':
			try:
				response = self.receive_response(soc, self.timeout/1000)
			except (IOError, select.error) as err:
				print 'Client Remote Server Response Error\\n{0}: {1}'.format(err[0], err[1])
				#return None, 'No valid response received from remote server'

		if count == self.retry_count:
			return None, 'Client retry count reached'

		print response
""", \
'remote_function_response_check' : """		json_obj = json.loads(response)
		if json_obj['status'] == 'OK' or json_obj['status'] == 'SUCCESS':
			if json_obj['size'] != len(json_obj['param']):
				print 'Client invalid parameter marshalling from server'
				return None, 'Return parameter checksum failure'

			ret_param_list = jsonpickle.decode(json_obj['param'])

			# return""", \
'remote_function_retval_check_if' : """			if """, \
'remote_function_retval_check_else' : """			else:
				return None, 'Invalid return value types'
		else:
			return None, '' + json_obj['status'] + ': An error occurred at the remote server'
"""}

#######################################################################################################################

'''This is the code templates for server skeleton. We typed these code blocks in such a way that
it only requires a small Python string Template generation for any kind of skeleton'''

SKELETON_CODE_BLOCKS = {\
'file_init' : """#!/usr/bin/env pyth
# -*- coding: utf-8 -*-

from __future__ import division
import numbers, json, jsonpickle, Pyro4, socket, select, exceptions, sys, threading

'''Automatically generated server skeleton script.
   Please do not edit this file by any means'''

MSGLEN = 4096
SERVERNAME = """, \
'class' : """
'''This class is a dummy server for locating the server. An instance of this class is registered
to the name server so that client can access the ip:port of the real server skeleton'''
class proxy_server(object):
    def __init__(self, name, host, port):
        self.name = name
        self.host = host
        self.port = port

    def get_host(self):
        return self.host

    def get_port(self):
        return self.port

def run_pyro_daemon(daemon):
    daemon.requestLoop()

'''Server skeleton. It serves through IP and some available port of the machine it is started on.
The skeleton has an instance of the server class that serves the respective functions.'''
class """, \
'class_init' : """
    def __init__(self, server_instance, timeout=10000, retry_count=5):
        self.server_instance = server_instance
        self.request_set = set()
        self.timeout = timeout
        self.retry_count = retry_count

        self.serversocket = self.init(SERVERNAME)

    # 
    def init(self, servername):
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            s.connect(("8.8.8.8", 80))
            host = s.getsockname()[0]
        except socket.error as err:
            print 'Socket Error: ', err
            sys.exit(0)
        finally:
            s.close()

        serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        serversocket.bind((host, 0))
        srv = proxy_server(servername, serversocket.getsockname()[0], serversocket.getsockname()[1])

        Pyro4.config.REQUIRE_EXPOSE = False
        daemon = Pyro4.Daemon()
        nameserver = Pyro4.locateNS()
        uri = daemon.register(srv)
        nameserver.register(srv.name, uri)

        threading.Thread(target=run_pyro_daemon, args=(daemon,)).start()
        print 'Pyro daemon started running...'

        return serversocket

    def receive_request(self, client, address):
        data = client.recv(MSGLEN)
        if data == '':
            raise IOError(2, 'Client socket disconnected')

        print data

        json_obj = json.loads(data)
        payload_size = str(json_obj['size'])
        func = json_obj['func']
        if str(len(json_obj['param'])) == payload_size:
            try:
                params = jsonpickle.decode(json_obj['param'])
            except:
                try: 
                    self.send_response(client, func, '', 'Unable to decode serialized parameters')
                except Exception as err:
                    client.shutdown(1)
                    client.close()
                    raise err
            
            if params[0] in self.request_set:
                try:
                    self.send_response(client, func, '', 'Recurrent Function Call')
                except Exception as err:
                    client.shutdown(1)
                    client.close()
                    raise err

            self.request_set.add(params[0])

            try:
                f = getattr(self.server_instance, func)
                input_param = params[1:]
                if not input_param:
                    retval = f()
                    print 'empty params: ',retval
                else:
                    retval = f(*input_param)
                    print 'non-empty params: ',retval
            except:
                try:
                    self.send_response(client, func, '', 'Invalid function name for server(' + SERVERNAME + ')')
                except Exception as err:
                    client.shutdown(1)
                    client.close()
                    raise err

            retval = list(retval)
            marshalled_param = jsonpickle.encode(retval)

            try:
                self.send_response(client, func, marshalled_param, 'SUCCESS')
            except Exception as err:
                client.shutdown(1)
                client.close()
                raise err

    def send_response(self, client, func_name, serialized_data, status):
        param_length = len(serialized_data)
        data = json.dumps({'size' : param_length, 'func' : func_name, 'param' : serialized_data, 'status' : status})
        msg_len = len(data)
        sent_amount = 0
        while sent_amount < msg_len:
            temp = client.send(data[sent_amount:])
            if temp == 0:
                raise IOError(0, 'Client socket disconnected')
            sent_amount += temp

        return 1

    def run(self):
        print 'Server started running...'
        print 'Listening on ' + self.serversocket.getsockname()[0] + ':' + str(self.serversocket.getsockname()[1])
        self.serversocket.listen(5)

        while 1:
            try:
                client, address = self.serversocket.accept()
                threading.Thread(target=self.receive_request, args=(client, address)).start()
            except KeyboardInterrupt as err:
                print 'Server terminated: ', err
                client.shutdown(1)
                client.close()
                break
            except Exception as err:
                print 'Problem while sending data back to client :', err

        print 'Server is shutting down...'"""}

#######################################################################################################################
#######################################################################################################################

def parse_args():
	if len(sys.argv) == 1:
		print 'Please provide the json interface definition file path\nAborting...'
		sys.exit()

	if len(sys.argv) > 1 and sys.argv[1] == '--help':
		print '\nWelcome!\n\npython_rpcgen is a tool that generates client stub and server skeleton code\n'
		print 'The tools accepts an interface definition JSON file that describes the service and its functions\n'
		print """The interface definition file should have the following structure:
{
	"service_name" : "name of the service",
	"version" : version number,
	"functions" : [
		{
			"function_name" : "name of the first function",
			"parameters" : {"parameter1" : "type1", "parameter2" : "type2"},
			"return" : {"returnValue1" : "type1", "returnValue2" : "type2"}
		}
	]
}"""
		sys.exit()

	with open(sys.argv[1], 'r') as f:
		return json.load(f)


def generate_stub_code(IDF):
	code = ''
	code += STUB_CODE_BLOCKS['file_init']
	code += '\'' + IDF['service_name'] + '\''
	code += """
class """ + IDF['service_name'] + ':'
	code += STUB_CODE_BLOCKS['class_init'] + """
"""
	code += STUB_CODE_BLOCKS['send_request']
	code += STUB_CODE_BLOCKS['receive_response']

	for i in xrange(len(IDF['functions'])):
		code += """	def """ + IDF['functions'][i]['function_name'] + '(self, '
		for obj in IDF['functions'][i]['parameters']:
			code += obj.items()[0][0] + ', '

		code += 'id):' + """
"""
		code += STUB_CODE_BLOCKS['remote_function_type_check']

		type_check = ""
		json_functions = IDF['functions']
		json_parameters = json_functions[i]["parameters"]
		for j in json_parameters:
			type_check_template = Template(' not isinstance($param, $type) ')
			type_check += type_check_template.substitute(param = j.items()[0][0],type=j.items()[0][1]) + 'or'
		type_check = type_check[:len(type_check)-3] +":\n\t\t\treturn None, 'Invalid input arguments'"

		code += type_check + """

"""
		code += STUB_CODE_BLOCKS['remote_function_nameserver'] + """
"""
		code += STUB_CODE_BLOCKS['remote_function_marshalling_begin'] + '[id'
		for obj in IDF['functions'][i]['parameters']:
			code += ', ' + obj.items()[0][0]

		code += """]
"""
		code += STUB_CODE_BLOCKS['remote_function_marshalling_end'] + """
"""
		code += STUB_CODE_BLOCKS['remote_function_connection'] + """
"""
		code += STUB_CODE_BLOCKS['remote_function_send_request'] + """
"""
		code += STUB_CODE_BLOCKS['remote_function_receive_response'] + """
"""
		code += STUB_CODE_BLOCKS['remote_function_response_check'] + """
"""
		code += STUB_CODE_BLOCKS['remote_function_retval_check_if']

		type_check = ""
		json_return = json_functions[i]["return"]
		for integer, j in enumerate(json_return):
			type_check_template = Template(' not isinstance(ret_param_list[$param], $type) ')
			type_check += type_check_template.substitute(param = integer,type=j.items()[0][1]) + 'or'
		type_check = type_check[:len(type_check)-3] +":\n\t\t\t\treturn ret_param_list, json_obj['status']"

		code += type_check + """

"""
		code += STUB_CODE_BLOCKS['remote_function_retval_check_else'] + """
"""

	with open(IDF['service_name'] + '_stub.py', 'w') as f:
		f.write(code)

def generate_skeleton_code(IDF):
	code = ''
	code += SKELETON_CODE_BLOCKS['file_init']
	code += '\'' + IDF['service_name'] + '\'' + """
"""
	code += SKELETON_CODE_BLOCKS['class']

	code += IDF['service_name'] + ':' + """
"""
	code += SKELETON_CODE_BLOCKS['class_init']

	with open(IDF['service_name'] + '_skeleton.py', 'w') as f:
		f.write(code)


IDF = parse_args()
generate_stub_code(IDF)
generate_skeleton_code(IDF)